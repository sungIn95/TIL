# 시간복잡도 & 빅오 표기법

좋은 알고리즘이란 무엇일까?

== 효율성이 좋은 알고리즘?

== 성능이 좋은 알고리즘?

시간복잡도 공간복잡도 있는데. 공간문제는 기술이 발전하면서 좋아겠다. 



시간 복잡도 (Time Complexity)

느린 알고리즘 시간 복잡도 높다

빠른 알고리즘 시간 시간복잡도가 낮다 



1기가 헤르츠 1초에 10억

![KakaoTalk_Photo_2022-07-26-11-16-32](0726.assets/KakaoTalk_Photo_2022-07-26-11-16-32-16588019131532.jpeg)

## 시간을 더 줄일거면 

공식을 알면 좋다. (복잡도가 상수가 나온다. )

=> 공식 정리 필요

예시) 가우스의 정리 (n * (n + 1)) // 2



![비용](0726.assets/비용-16588021548185.JPG)



[파이썬 비용](https://wiki.python.org/moin/TimeComplexity)

google 검색: big i cheat sheet

# 리스트

## 배열 vs 연결리스트

파이썬의 리스트는

다른 언어의 배열 비슷

여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료 구조

빼곡한 약통 같은 느낌 

| 메모리 주소 | 1000 | 1004 | 1008 | 1012 | 1016 |
| ----------- | ---- | ---- | ---- | ---- | ---- |
| 데이터      | 70   | 80   | 20   | 100  | 90   |
| 인덱스      | A[0] | A[1] | A[2] | A[3] | A[4] |

배열에 중간에 뭘 추가할려면 

공간을 만들고 자료를 이동시키는 것이다. 



# string

문자열은 immutable(변경 불가능한) 자료형!

word = "apple"

word += "banana"

word = "apple"주소값은 삭제된다(약간 개념은 다르지만 치워준다. )

## 문자열 승라이싱

```python
s = 'abcdefghi'

s[2:5:2] "ce"
s[-6:-1:3] "dg"
s[2:5:-1] ""
s[5:2:-1] "fg"
s[:3] "abc"
s[5:] "fghi"

```

2).strip(제거한 문자. )

원본은 변하지 않는다. 

3).find(찾는문자) vs .index(찾는문자)

차이점: 없으면 -1 ,   error

6).replace

word = "happyhacking"

print(word.replace("happy", "angry"))

angryhacking

# 아스키(ASCII) 코드 

컴퓨터는 숫자만 이해할 수 있다!

비트 0,1

바이트 1byte == 8 bits

8자리 맨앞 문자인지 아닌지를 나타내서

7자리 2의7승 128개 까지 있다. 

ord 문자 => 숫자 

chr 숫자 => 문자









# 딕셔너리

파이썬의 딕셔너리(Dictionary)는 해시 함수와 해시 테이블을 이용하여 삽입, 삭제, 수정, 조회 연산의 속도가 리스트보다 빠르다.

해시 함수: 안녕, 대한민국 헌법, 미국 헌법 모두 같은 크기의 데이터로 저장이 된다. (16진법의 수) SHA256

삽입, 삭제, 수정, 조회 무엇을 하든 (o)1로 가능하다. 

## Q: 왜 헷갈리게 john{"name}이 아니고 john["name"]일까요

조회할 때는 []. 리스트경우 리스트라서 []가 아니라 조회할때는 []를 사용한다. 



## Counting(흑마법)

카운터 할떄 

counter[score] += 1 이런식으로 간단하게 할 수 있다. 

```python
# Counting
from collections import Counter

scores = ["A", "A","C","D","A","B","B"]

easy_counter = Counter(scores)

print(easy_counter)
```

위에 흑마법 세트는 3주 후에 모두 공개 예정ㅋㅋㅋ













