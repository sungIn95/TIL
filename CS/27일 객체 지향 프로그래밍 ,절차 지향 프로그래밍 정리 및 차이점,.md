27일 객체 지향 프로그래밍 ,절차 지향 프로그래밍 정리 및 차이점,

[참고 블로그](https://jongminfire.dev/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80)

# 객체 지향 프로그래밍이란?

객체 지향 프로그래밍 (Object-Oriented Programming, OOP)은 프로그래밍에서 필요한 데이터를 추상화 시켜 `상태와 행위를 가진 객체`로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.



추상화 후 상호작용을 통해 로직 구성



## 객체란?

객체는 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며 값을 저장 할 `변수`와 작업을 수행 할 `메소드`를 서로 연관된 것들끼리 묶어서 만든 것을 객체라고 할 수 있다.

객체지향 프로그래밍을 레고에 빗대 표현 할 수 있는데, `객체`가 레고의 조각이 될 것이고 레고의 조각을 조립해서 무언가를 만드는 방식이 객체지향 프로그래밍이라고 할 수 있다.



객체는 참조되는 공간

값 저장: 변수

작업 수행: 메소드

이를 묶어서 객체



![lego](https://jongminfire.dev/static/1f2b3463cc0a830e4e2a8ac4843d4b4a/18e3b/lego.jpg)



객체는 또한 레고 조각과도 비슷하게 여러군데에서 재사용 할 수 있는데 이는 `부품화` 와 `재사용성` 이라는 객체 지향 프로그래밍의 특징을 보여주기도 한다.



함수는 이 블록으로 작품을 만들고 그 작품을 복사 가능하게 한게 아닐까 싶다. 



## 객체 지향 프로그래밍 언어

객체지향 프로그래밍을 지원하는 언어로는 `C++ , C# , Java , Python , JavaScript , Ruby , Swift` 등이 있다. 더 많은 언어를 알고 싶다면 [객체 지향 언어](https://ko.wikipedia.org/wiki/객체_지향_프로그래밍#객체_지향_언어)를 참고해보자.



## 객체 지향 프로그래밍의 특징

객체 지향 프로그래밍은 크게 `추상화` , `캡슐화` , `상속` , `다형성` 의 네가지 특징을 가진다.



### 1. 추상화

- 객체에서 공통된 속성과 행위를 추출 하는 것
- 공통의 속성과 행위를 찾아서 타입을 정의하는 과정
- 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단하게 만드는 것



클래스 혹은 함수를 만드는 과정이 대표적인거 같다. 



### 2. 캡슐화

- 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶는 것 (변수와 함수를 하나로 묶는 것을 뜻함)
- 낮은 결합도를 유지할 수 있도록 설계하는 것



속성과 기능을 정의하는 변수와 메소드를 클래스라는 캡슐에 넣어서 분류하는 것으로 재활용이 원활하다는 장점이 있고 캡슐화를 통해서 `정보은닉` 을 활용 할 수도 있다. (접근제어자의 활용)



추상화와 비슷한 맥락인듯하다. 



### 3. 상속

- 클래스의 속성과 행위를 하위 클래스에 물려주거나 하위 클래스가 상위 클래스의 속성과 행위를 물려받는 것을 말한다
- 새로운 클래스가 기존의 클래스의 데이터와 연산을 이용할 수 있게 하는 기능



상속을 하게 된다면 장단점이 존재하는데 이는 다음과 같다.

| 장점                                                         | 단점                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| - 재사용으로 인한 코드가 줄어든다 - 범용적인 사용이 가능하다 - 자료와 메서드의 자유로운 사용 및 추가가 가능하다 | - 상위 클래스의 변경이 어려워진다 - 불필요한 클래스가 증가할 수 있다 - 상속이 잘못 사용될 수 있다 |



### 4. 다형성

- 하나의 변수명, 함수명이 상황에 따라 다른 의미로 해석 될 수 있는 것
- 어떠한 요소에 여러 개념을 넣어 놓는 것



객체 지향 프로그래밍은 하나의 클래스 내부에 같은 이름의 행위를 여러개 정의하거나 상위 클래스의 행위를 하위 클래스에서 재정의하여 사용할 수 있기 때문에 다형성이라는 특징을 갖게 된다.



**오버라이딩**

- 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용하는 것

**오버로딩**

- 같은 이름의 메서드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것



상속에 상속을 말하는 건가?



## 객체 지향 프로그래밍의 장단점



### 장점

- 클래스 단위로 모듈화시켜서 개발하기 때문에 `업무 분담이 편리`하고 `대규모 소프트웨어 개발에 적합`하다.
- 클래스 단위로 수정이 가능하기 때문에 `유지 보수가 편리`하다.
- 클래스를 재사용하거나 상속을 통해 확장함으로써 `코드 재사용이 용이`하다.



### 단점

- `처리속도가 상대적으로 느리다`.
- 객체의 수가 많아짐에 따라 `용량이 커질 수 있다`.
- `설계시 많은 시간과 노력이 필요`하게 될 수 있다.



[참고 블로그](https://blog.naver.com/PostView.naver?blogId=gitacademy01&logNo=222394033958&redirect=Dlog&widgetTypeCall=true&directAccess=false)

# 절차지향언어 (Procedural Programming)

절차지향 프로그래밍에 쓰이는 언어를 절차지향언어라고 하며, 대표적인 예로는 c언어가 있습니다. 

절차지향언어는 개체를 순차적으로 처리하여 프로그램 전체가 유기적으로 연결되어야 합니다.

자동차 제조를 예로 들자면, 자동차는 엔진, 차체, 핸들, 의자, 바퀴 순으로 차례대로 만들어져야 합니다. 서로 분리되어도 안 되고, 순서가 틀려도 안 됩니다. 절차지향 프로그래밍 역시 이와 같습니다. 



절차지향언어의 구조는 컴퓨터의 처리구조와 유사합니다. 따라서 실행 속도가 빠르다는 것이 장점입니다.

하지만, 핸들이 고장났다고 엔진부터 바퀴까지 전부 수리해야 한다면 얼마나 비효율적일까요?

소프트웨어가 눈부신 발전을 이루면서 절차지향언어의 단점이 두드러지게 됩니다. 



## 절차지향언어의 단점

1. 유지보수의 어려움

모든 구성요소가 유기적으로 연결되어 있다는 말은, 하나가 고장났을 때 시스템 전체가 고장난다는 뜻입니다. 

또한 문제를 해결하기 위해 일부분이 아닌 시스템 전체를 수리해야 한다는 말이기도 합니다. 

절차지향언어는 이러한 유지 보수가 매우 까다로운 편이며, 특히 디버깅(프로그램의 문제를 찾아내어 고치는 과정)이 어렵습니다.



2. 엄격하게 순서가 정해져 있어 비효율적

실행 순서가 정해져 있기 때문에 코드의 순서가 바뀌면 결과가 달라질 가능성이 높습니다. 

즉, 언어의 융통성이 부족하여 생산 효율이 떨어집니다. 



> **객체 지향 프로그래밍의 반대는 절차 지향 프로그래밍이다?**
>
> *객체 지향 프로그래밍은 절차 지향 프로그래밍과 장단점이 겹치는 부분이 있기 때문에 그렇게 생각이 들 수 있다. 하지만 절차지향은 순차적으로 실행에 초점이 되어있고 객체지향은 관계/조직에 초점을 맞추고 있다는 초점의 차이일 뿐이다.*
> 절차적 프로그래밍이라고 해서 객체를 다루지 않는 것이 아니고, 객체지향 프로그래밍이라고해서 절차가 없는 것도 아니다.



개인적으로는 객체지향이 유통성이 있어서 좋을꺼 같다. 절차지향은 유통성이 적어서 코드를 만들다 보면 에러 사항이 많을꺼 같다. 다만, 간단하면서 대규모의 트레픽이 나오는 구조라면 절차지향을 사용하는 것이 좋을거 같다. 



### 그외

##### SOLID (객체 지향 설계 원칙)

객체 지향적으로 설계하기 위해 `SOLID` 라 불리는 다섯 가지 원칙이 있다.



###### 1. 단일 책임 원칙 (SRP, Single Responsibility Principle)

- 하나의 클래스는 단 하나의 책임만 가져야 한다.
- 단일 책임 원칙을 지키지 않을 경우 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.

###### 2. 개방-폐쇄 원칙 (OCP, Open/Closed Principle)

- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.

###### 3. 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)

- 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

###### 4. 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)

- 범용 인터페이스 하나보다 클라이언트를 위한 여러 개의 인터페이스로 구성하는 것이 좋다.
- 인터페이스는 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
- 클라이언트가 필요로 하는 인터페이스로 분리함으로써 각 클라이언트가 사용하지 않는 인터페이스에 변경이 있어도 영향을 받지 않도록 만들어야 한다.

###### 5. 의존관계 역전 원칙 (DIP), Dependency Inversion Principle)

- 추상화에 의존해야지 구체화에 의존하면 안된다.
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되고 저수준 모듈은 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.



여기는 아직까지 이해를 못하겠다. 